#!/usr/bin/python
# -*- coding: utf-8 -*-
""" $Id$
"""


import cgi
import sys
import os
import urlparse
import urllib
import httplib
import surbl

Page = """
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US">
<head><title>HTML Diff service</title>
<link rel="stylesheet" href="http://www.w3.org/StyleSheets/base" />
</head>
<body>

<p><a href="http://www.w3.org/"><img src="http://www.w3.org/Icons/w3c_home" alt="W3C"/></a> <a href="http://www.w3.org/2003/Editors">W3C Editors homepage</a></p>

<h1>Create Diff between HTML pages</h1>
"""
Page2 = """
<form method="GET">
<p>Address of reference document: <input name="doc1" value="%s"/></p>
<p>Address of new document: <input name="doc2" value="%s"/></p>
<p><input type="submit" value="get Diff"/></p>
</form>

<p><strong>Tip</strong>: if the document uses the W3C convention on linking to its previous version, you can specify only the address of the new document — the previous link will be automatically detected.</p>
<address>
script $Revision$ of $Date$<br />
by <a href="http://www.w3.org/People/Dom/">Dominique Hazaël-Massieux</a><br />based on <a href="http://htmlwg.mn.aptest.com/viewcvs/viewcvs.cgi/htmldiff/htmldiff">Shane McCarron’ Perl script</a> wrapped in a <a href="http://dev.w3.org/cvsweb/2009/htmldiff/">Python CGI</a>
</address>
</body>
</html>
"""

def checkInputUrl(url):
    checker = surbl.SurblChecker('/usr/local/share/surbl/two-level-tlds','/afs/w3.org/pub/WWW/Systems/Server/debian/generic/usr/local/etc/surbl.whitelist')

    if  url[:5] == 'file:' or len(urlparse.urlparse(url)[0])<2:
        print "Status: 403"
        print "Content-Type: text/plain"
        print
        print "sorry, I decline to handle file: addresses"
        sys.exit()
    elif checker.isMarkedAsSpam(url):
        print "Status: 403"
        print "Content-Type: text/plain; charset=utf-8"
        print
        print "sorry, this URL matches a record known in SURBL. See http://www.surbl.org/"
        sys.exit()

def setupRequest(urlopener, headers):
    if headers.has_key('If-Modified-Since'):
        urlopener.addheader("If-Modified-Since: %s" % (headers["If-Modified-Since"]))
    if os.environ.has_key('REMOTE_ADDR') and os.environ['REMOTE_ADDR']:
        urlopener.addheader('X_Forward_IP_Addr',os.environ['REMOTE_ADDR'])


def serveRequest():
    fields = cgi.FieldStorage()

    if (not fields.has_key('doc2')):
        print "Content-Type: text/html;charset=utf-8"
	print
        print Page
	print Page2 % ("","")
    else:
        # if doc1 is not specified, we load doc2 to check if it has a previous version link
        doc2 = fields['doc2'].value
        checkInputUrl(doc2)
        import http_auth
        import re
        url_opener2 = http_auth.ProxyAuthURLopener()
        setupRequest(url_opener2, fields.headers)
        try:
            import StringIO
            urldoc = url_opener2.open(doc2)
            if not urldoc: # 401?
                print
                print Page
                print Page2 % ("","")
                sys.exit()
            newheaders = urldoc.info()
            newdoc = StringIO.StringIO(urldoc.read())
        except IOError, (errno, strerror):
            url_opener.error = "I/O error: %s %s" % (errno,strerror)
            newdoc = None
        except httplib.InvalidURL:
            url_opener.error = "Invalid URL submitted"
            newdoc = None
        if (not fields.has_key('doc1')):
            from BeautifulSoup import BeautifulSoup

            soup = BeautifulSoup(newdoc.read())
            newdoc.seek(0)
            try:
                doc1 = soup.find(text=re.compile("Previous Version",re.IGNORECASE)).findNext(name="a", attrs={"href":True})["href"]
            except:
                doc1 = None
        else:
            doc1 = fields['doc1'].value
        if (not doc1):
            print "Content-Type: text/html;charset=utf-8"
            print
            print Page
            print Page2 % ("","")
            sys.exit()

        checkInputUrl(doc1)
        urlcomponents1 = urlparse.urlparse(doc1)
        urlcomponents2 = urlparse.urlparse(doc2)
        # if same domain, we can use the same urlopener
        # otherwise, we create a separate one
        if urlcomponents2[1] == urlcomponents1[1]:
            url_opener = url_opener2
        else:
            url_opener = http_auth.ProxyAuthURLopener()
        setupRequest(url_opener, fields.headers)

        try:
            refdoc = url_opener.open(doc1)
        except IOError, (errno, strerror):
            url_opener.error = "I/O error: %s %s" % (errno,strerror)
            refdoc = None
        except httplib.InvalidURL:
            url_opener.error = "Invalid URL submitted"
            refdoc = None
        if refdoc and newdoc:
            if newheaders.has_key('Content-Type'):
                contentType = cgi.parse_header(newheaders["Content-Type"])
                if contentType[1].has_key('charset'):
                    from string import lower
                    charset = lower(contentType[1]['charset'])
                    print "Content-Type: text/html"
                    # option for tidy
                    options = dict(output_xhtml=1,tidy_mark=0,show_warnings=0,quiet=1)
                    if charset == "iso-8859-1":
                        options["char_encoding"]='latin1'
                    else:
                        options["char_encoding"]='utf8'

            import tidy
            from tempfile import NamedTemporaryFile
            tmp1 = NamedTemporaryFile('w')
            tmp2 = NamedTemporaryFile('w')
            tmp1.write(refdoc.read())
            src = newdoc.read()
            html5doctype = re.compile("<!doctype\s+html\s*>", re.IGNORECASE)
            html5 = html5doctype.search(src)
            if html5:
                html5_tidy_options = {"add_xml_space": "no",
                                      "output_xhtml": "yes",
                                      "tidy_mark": "no",
                                      "new_blocklevel_tags": '"article,aside,canvas,dialog,details,figcaption,figure,footer,header,hgroup,menu,nav,section,summary"',
                                      "new_inline_tags": '"video,audio,canvas,ruby,rt,rp,time,meter,progress,track,source"',
                                      "break_before_br": "no",
                                      "vertical_space": "no",
                                      "enclose_text": "no",
                                      "numeric_entities": "yes",
                                      "wrap": "1000",
                                      "wrap_attributes": "no",
                                      "drop_empty_paras": "no"
                                      }
                options = dict(options.items() + html5_tidy_options.items())
            newtidy = tidy.parseString(src, **options)
            tmp2.write(newtidy.__str__())
            tmp1.flush()
            tmp2.flush()
            refheaders = refdoc.info()
            if newheaders.has_key('Last-Modified'):
                print "Last-Modified: %s" % ( newheaders["Last-Modified"] )
                charset = ""
                contentType="text/html"
                        
            if newheaders.has_key("Expires"):
                print "Expires: %s" % (newheaders['Expires'] )
            print
            command=["/usr/local/bin/htmldiff",tmp1.name,tmp2.name]
            from subprocess import Popen, PIPE
            p = Popen(command,stdin=None, stdout=PIPE, stderr=PIPE)
            sys.stdout.flush()
            sys.stderr.flush()
            (out,err) = p.communicate()
            if err:
                print Page
                print "<p style='color:#FF0000'>An error occured when running <code>htmldiff</code> on the documents:</p>"
                print "<pre>%s</pre>" % (cgi.escape(err))
                print Page2 % (cgi.escape(doc1),cgi.escape(doc2))
            else:
                output = tidy.parseString(out, **options)
                if not output == "\n":
                    output = out
                    print output

        else:
            print "Content-Type: text/html;charset=utf-8"
            print
            print Page
            print "<p style='color:#FF0000'>An error (%s) occured trying to get <a href='%s'>%s</a> or <a href='%s'>%s</a>.</p>" % (cgi.escape(url_opener.error),cgi.escape(doc1),cgi.escape(doc1),cgi.escape(doc2),cgi.escape(doc2))
            print Page2 % (cgi.escape(doc1),cgi.escape(doc2))
            
if __name__ == '__main__':
    if os.environ.has_key('SCRIPT_NAME'):
        serveRequest()

